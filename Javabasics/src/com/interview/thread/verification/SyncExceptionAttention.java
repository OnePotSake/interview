package com.interview.thread.verification;

import java.util.concurrent.TimeUnit;

/**
 * 程序在执行过程中，如果出现异常，默认情况锁会被释放
 * 所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。
 * 比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适，
 * 在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。
 * 因此要非常小心的处理同步业务逻辑中的异常
 */
public class SyncExceptionAttention {
  private volatile  Integer account = 0;
  synchronized void m() {
    while(true){
      account++;
      try {
        System.out.println(Thread.currentThread().getName() + " count = " + account);
        TimeUnit.SECONDS.sleep(1);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }

      if (account == 5) {
        System.out.println(5 / 0);
      }
    }
  }

  public static void main (String[] args) {
    SyncExceptionAttention syncExceptionAttention = new SyncExceptionAttention();
    // 验证同步异常逻辑
    new Thread(()->{
      syncExceptionAttention.m();

    }, "t3").start();

   // 其余线程一样可以获取其他资源,故多线程情况要多注意,若其他线程异常,其余线程仍然可以在有问题的资源上继续操作
      new Thread(()->{
        try {
          TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
        syncExceptionAttention.m();
      }, "t1").start();

  }
}
